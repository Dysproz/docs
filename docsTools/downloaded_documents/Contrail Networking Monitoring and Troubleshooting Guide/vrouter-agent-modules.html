<p id="topic-content"><h1 id="jd0e2">Agent Modules in Contrail Networking</h1><sw-topic-details date="2020-09-11"> </sw-topic-details><p>The VNsw Agent (also called Agent) in Contrail Networking is
responsible for managing the data plane component. It is similar to
any datapath agent that runs on the line cards of a network node.
Agent responsibilities include:</p><ul><li style=""><p>Interface with <code class="inline" v-pre="">contrail-controller</code> to get the configuration. Agent receives the configuration and translates
it into a form that the datapath can understand.</p></li><li style=""><p>Interface with <code class="inline" v-pre="">contrail-controller</code> to manage routes.</p></li><li style=""><p>Collect and export statistics from datapath.</p></li><li style=""><p>Translate the data model from IF-MAP to the data model
used by datapath.</p></li></ul><p>Agent contains the following modules:</p><ul><li style=""><p>Config</p></li><li style=""><p>Oper-DB</p></li><li style=""><p>Controller</p></li><li style=""><p>UVE</p></li><li style=""><p>Pkt</p></li><li style=""><p>Services</p></li><li style=""><p>KSync</p></li></ul><p>Agent by itself is not a program or daemon. Based on the platform,
daemons are built using the modules listed above. The <code class="inline" v-pre="">contrail-vxlan-agent</code> is the port of <code class="inline" v-pre="">contrail-vrouter-agent</code> on platforms supporting VXLAN bridges. <a href="vrouter-agent-modules.html#agent-modules">Figure 1</a> provides an overview of the different modules involved.</p><figure id="agent-modules"><figcaption>Figure 1: Overview of Agent Modules</figcaption><div class="graphic"><img alt="Overview of Agent Modules" src="documentation/images/g301126.png" style=""/></div></figure><h2 id="jd0e70">Config</h2><p>Config module implements the northbound interface for Agent.
Agent gets two types of configurations, virtual machine ports and
IF-MAP.</p><h3 id="jd0e75">Virtual-Machine Ports</h3><p>Agent opens a thrift service (name InstanceService) to listen
for Port-Add/Port-Delete message. Port-Add informs agent about a virtual
machine (VM) interface created on the compute node. The Port-Add message
also contains the following information:</p><ul><li style=""><p>Name of virtual machine port.</p></li><li style=""><p>Virtual machine for the port.</p></li><li style=""><p>Mac and IP address for the port.</p></li><li style=""><p>Virtual network for the port.</p></li></ul><p>Once agent knows about the creation of a port, it will send
a subscribe message to <code class="inline" v-pre="">contrail-controller</code> for <code class="inline" v-pre="">virtual-machine</code>. When <code class="inline" v-pre="">contrail-controller</code> receives the subscribe message
for a <code class="inline" v-pre="">virtual-machine</code>, it walks through
the IF-MAP graph and sends all configuration relevant for the <code class="inline" v-pre="">virtual-machine</code> to the Agent. The module invoking port
add message is platform dependent. In the case of OpenStack, <code class="inline" v-pre="">nova-compute</code> service invokes the message.</p><h3 id="jd0e113">IF-MAP</h3><p>All of the Contrail Virtual Network Controller (VNC) configuration
is stored as a Metadata Access Point (MAP) database. The MAP database
is accessed using IF-MAP protocol.</p><p>Agent does not access the MAP database directly. Instead, Agent
opens an XMPP connection to <code class="inline" v-pre="">contrail-controller</code> to get the MAP configuration. The <code class="inline" v-pre="">contrail-controller</code> works on a subscription model. Agent must subscribe to the virtual
machines of interest and <code class="inline" v-pre="">contrail-controller</code> will download all of the configuration relevant to the <code class="inline" v-pre="">virtual-machine</code>. As a result, Agent receives only the
minimal configuration needed. Agent subscribes to a <code class="inline" v-pre="">virtual-machine</code> when it receives a port add message for a <code class="inline" v-pre="">virtual-machine-interface</code>.</p><p>Agent uses the <code class="inline" v-pre="">ifmap-agent-client</code> library to parse the IF-MAP messages from the XMPP channel to the <code class="inline" v-pre="">contrail-controller</code>. The <code class="inline" v-pre="">ifmap-agent-client</code> defines a <code class="inline" v-pre="">DBTable</code> for every IF-MAP node
type. A special <code class="inline" v-pre="">DBTable</code> is defined to store
the IF-MAP links. The <code class="inline" v-pre="">ifmap-agent-client</code> also creates a graph for ease of navigating the IF-MAP configuration.
An IF-MAP node is vertex in the graph and links form the edges in
the graph.</p><h3 id="jd0e158">Configuration Management</h3><p>Config module registers <code class="inline" v-pre="">DBTables</code> of
interest from the <code class="inline" v-pre="">ifmap-agent-client</code> library.
Any add, delete, or update of the configuration results in a callback
to the Config module. The Config module then does basic validation
on the config nodes and then triggers the operational module to process
the configuration.</p><h3 id="jd0e169">Redundancy</h3><p>Agent connects to two different control nodes for redundancy.
When the XMPP connection for one of the control node fails, it will
subscribe to the other control node for configuration. When connecting
to the new control node, Config module audits the configuration to
remove stale configuration.</p><h2 id="jd0e174">Oper-DB</h2><p>The Oper-DB module holds the operational state of the different
objects in Agent. The operational state processes the configuration
and creates different tables appropriate for Agent.</p><p>Following are the principal tables in Oper-DB:</p><h3 id="jd0e181">Virtual Network</h3><p>Table of all <code class="inline" v-pre="">virtual-networks</code> with
UUID as the key. It contains the following information:</p><sw-table><p class="SubTitle" id="jd0e189">Table 1: Virtual Network Table</p><table cellspacing="0" style="border-top:thin solid black;" width="99%"><thead><tr valign="bottom"><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Item</p></th><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Description</p></th></tr></thead><tbody><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>VRF</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>The <code class="inline" v-pre="">routing-instance</code> for the <code class="inline" v-pre="">virtual-network</code>.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>IPAM Data</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>The IP Address Management (IPAM) configured for the <code class="inline" v-pre="">virtual-network</code>. It includes DHCP configuration, DNS
configuration, subnet configuration, and so on.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Network Policy</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Network policy access control list (ACL) for the <code class="inline" v-pre="">virtual-network</code>.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Mirroring</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Mirroring ACL for the <code class="inline" v-pre="">virtual-network</code>.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>VXLAN-ID</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Virtual Extensible Local Area Network ID (VXLAN-ID) to be used
when VXLAN encapsulation is used.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Layer 3 Forwarding</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Specifies if <code class="inline" v-pre="">layer3_forwarding</code> is
enabled for IPv4 and IPv6 packets.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Bridging</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Specifies if bridge forwarding is enabled. Even if <code class="inline" v-pre="">layer3_forwarding</code> is disabled, IPv4 and IPv6 packets
are bridge forwarded.</p></td></tr></tbody></table></sw-table><h3 id="jd0e274">VRF</h3><p>The virtual routing and forwarding (VRF) table represents a <code class="inline" v-pre="">routing-instance</code> in configuration. Each <code class="inline" v-pre="">virtual-network</code> has a "native" VRF. Other than the
per <code class="inline" v-pre="">virtual-network</code> VRF, there can be other
internal VRFs. The internal VRFs are used in features, such as service
chaining.</p><p>Each VRF has a set of routing tables as its members.</p><sw-table><p class="SubTitle" id="jd0e290">Table 2: VRF Routing Tables</p><table cellspacing="0" style="border-top:thin solid black;" width="99%"><thead><tr valign="bottom"><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Table</p></th><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Description</p></th></tr></thead><tbody><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Inet4 Unicast Table</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Table containing inet4 unicast routes.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Inet4 Multicast Table</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Table containing inet4 multicast routes.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>EVPN Table</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Table containing EVPN routes keyed with MAC address, IP address,
and <code class="inline" v-pre="">vxlan/ethernet_tag</code>.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Bridge Table</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Table containing MAC addresses. The bridge table is currently
used only in the case of a "native" VRF for a <code class="inline" v-pre="">virtual-network</code>.</p></td></tr><tr valign="top"><td align="left" colspan="2" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Based the platform used, Agent creates some VRFs implicitly:</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>OpenStack</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Agent implicitly creates a VRF for <code class="inline" v-pre="">fabric-network</code> with the name <code class="inline" v-pre="">default-domain:default-project:ip-fabric:__default__</code>.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Xen</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Agent implicitly creates a VRF for <code class="inline" v-pre="">fabric-network</code> with the name <code class="inline" v-pre="">default-domain:default-project:__link_local__</code>.</p></td></tr></tbody></table></sw-table><h3 id="jd0e369"> Virtual Machine</h3><p>The virtual machine table stores all <code class="inline" v-pre="">virtual-machines</code> created on the compute node.</p><h3 id="jd0e377">Interface</h3><p>The interface table contains all of the interfaces in Agent.
Based on the type of interface, the trigger to create an interface
can vary. Also, the key fields used to uniquely identify the interface
and the data fields in an interface can vary based on the type of
interface.</p><p>Agent supports the following different types of interfaces:</p><sw-table><p class="SubTitle" id="jd0e384">Table 3: Interface Types Supported by Agent</p><table cellspacing="0" style="border-top:thin solid black;" width="99%"><thead><tr valign="bottom"><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Item </p></th><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Description</p></th></tr></thead><tbody><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Physical Interface</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Represents physical ports on the compute node. Physical interfaces
are created based on the <code class="inline" v-pre="">config-file</code> for
Agent.</p><p>Key for physical interface is <code class="inline" v-pre=""><var v-pre="">&lt;interface-name&gt;</var></code>.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Packet Interface</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Interface used to exchange packets between vRouter and Agent.
Typically named <code class="inline" v-pre="">pkt0</code>, this interface is
automatically created in Agent.</p><p>Key for packet interface is <code class="inline" v-pre=""><var v-pre="">&lt;interface-name&gt;</var></code>.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Inet interface</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>he layer 3 inet interfaces are managed by Agent. Agent can have
one or more inet interfaces based on the platform used.</p><ul><li style=""><p>OpenStack: In the case of OpenStack, Agent creates the <code class="inline" v-pre="">vhost0</code> inet-interface. <code class="inline" v-pre="">vhost0</code> is a layer 3 interface in <code class="inline" v-pre="">host-os</code>. Agent
uses this layer 3 interface for tunnel encapsulation and decapsulation.
The interface is added into the fabric VRF.</p></li><li style=""><p>Xen: In the case of Xen, Agent creates the <code class="inline" v-pre="">xapi0</code> interface. The <code class="inline" v-pre="">xapi0</code> interface is added into the Xen <code class="inline" v-pre="">link-local</code> VRF.</p></li><li style=""><p>vGW: Every vGW Virtual Gateway instance has a vGW interface
created. The vGW interface is an unnumbered interface and does not
have an IP address.</p><p>Key for inet interface is <code class="inline" v-pre=""><var v-pre="">&lt;interface-name&gt;</var></code>.</p></li></ul></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>VM Interface</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>This interface represents a <code class="inline" v-pre="">virtual-machine-interface</code>. The interface is created when Agent receives an <code class="inline" v-pre="">AddPort</code> message from the Apache Thrift service <code class="inline" v-pre="">InstanceService</code>.</p><p>Key for VM interface is UUID for the interface.</p></td></tr></tbody></table></sw-table><p>An interface is in <strong v-pre="">Active</strong> state if all of the necessary
configuration for the interface is available and it can be made operational.</p><p>An interface is in <strong v-pre="">Inactive</strong> state if it cannot be
made operational. The reason can be missing configuration, the <code class="inline" v-pre="">link-state</code> down, and so on.</p><h3 id="jd0e503">Routes</h3><p>Every VRF has a set of routing tables for inet4 unicast routes,
inet4 mulitcast routes, EVPN routes, and bridge MAC entries.</p><p>Every route specifies the forwarding action for a destination.
Agent has multiple modules that can have different views of forwarding
action for a destination. Each forwarding action is specified in the
form of a path. Each module that adds a path is identified by a peer
in the path.</p><p>Route keeps the list of paths sorted. The head of this list
is treated as the <strong v-pre="">Active</strong> path for the route.</p><p>Every path contains next hop that describes forwarding action.</p><p>The unicast routing table also maintains route entries in the
Patricia tree form to support longest prefix match (LPM) on the tree.</p><h3 id="jd0e519">Next Hop</h3><p>Next hop describes the forwarding action for routes pointing
to it. When route lookup for an address hits the route, the forwarding
action for the packet is defined by the next hop.</p><p>The different types of next hop supported in Agent are:</p><sw-table><p class="SubTitle" id="jd0e526">Table 4: Next Hop Types Supported by Agent</p><table cellspacing="0" style="border-top:thin solid black;" width="99%"><thead><tr valign="bottom"><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Type</p></th><th align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Description</p></th></tr></thead><tbody><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Discard</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Packets hitting <code class="inline" v-pre="">Discard</code> next hop
must be dropped.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Receive</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Packets hitting <code class="inline" v-pre="">Receive</code> next hop
are destined to the <code class="inline" v-pre="">host-os</code>. The next hop
has an interface on which packets must be transmited.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Resolve</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Packets hitting <code class="inline" v-pre="">Resolve</code> next hop
need ARP resolution. For example, if IP address 10.1.1.1/24 is assigned
to interface <code class="inline" v-pre="">vhost0</code>, the following routes
and next hop are generated.</p><ul><li style=""><p>Route 10.1.1.1/32 is added with <code class="inline" v-pre="">Receive</code> next hop pointing to <code class="inline" v-pre="">vhost0</code>.</p></li><li style=""><p>Route 10.1.1.0/24 is added with <code class="inline" v-pre="">Resolve</code> next hop. Any packet hitting this route triggers ARP resolution.</p></li></ul></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>ARP</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Routes created as a result of ARP resolution, that point to
ARP next hop. In the example above, you can have routes 10.1.1.1.2/32,
10.1.1.3/32, and so on pointing to ARP next hop.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Interface</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Specifies that packets hitting this next hop must be transmitted
on the interface.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Tunnel</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Specifies that packets hitting this next hop must be encapsulated
in a tunnel. The tunnel next hop specifies tunnel destination IP address.
The packet post tunneling is routed on the fabric network.</p></td></tr><tr valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Multicast Composite</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Mulitcast composite next hop contains a list of component next
hops. Packets hitting the multicast composite next hop are replicated
and transmitted on all the component next hops.</p></td></tr><tr class="row-with-bg" valign="top"><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>ECMP Composite</p></td><td align="left" style="border-bottom:thin solid black;text-align: left;padding-right: 10px;padding-left: 10px;"><p>Equal Cost Multi-Path (ECMP) composite next hop contains a list
of component next hops. Packets hitting the ECMP composite next hop
must be sent out on one of the component next hops. Packet forwarding
component must ensure that packets for a connection are always transmitted
on the same component next hop of a ECMP composite next hop.</p><p>ECMP composite next hop is used to load balance traffic across
multiple next hops.</p></td></tr></tbody></table></sw-table><h3 id="jd0e630">MPLS</h3><p>The MPLS label defines the forwarding action for MPLS tunneled
packets received on the fabric network.</p><p>Agent assigns the following labels:</p><ul><li style=""><p>Two labels are allocated for every VM interface.</p><ul><li style=""><p>A label for layer 3 packets.</p></li><li style=""><p>A label for bridge packets.</p></li></ul></li><li style=""><p>A label for every ECMP composite next hop.</p></li><li style=""><p>A label for every multicast composite next hop.</p></li></ul><p>The <code class="inline" v-pre="">label-range</code> for multicast composite
next hop is preallocated and does not overlap with other labels.</p><h3 id="jd0e659">Multicast</h3><p>Multicast module is responsible for managing multicast routes.</p><h3 id="jd0e664">VXLAN</h3><p>The VXLAN table contains an entry for every VXLAN ID created.</p><h2 id="jd0e669">Controller</h2><p>This module manages the communication between Agent and <code class="inline" v-pre="">contrail-controller</code>. Agent connects to two Contrail
controllers for redundancy. Two XMPP channels are opened with each
of the Contrail controllers.</p><h3 id="jd0e677">Configuration Channel</h3><p>The Contrail controller uses this channel to send IF-MAP configuration
to Agent. Agent subscribes to configuration from only one of the XMPP
channels at a time. If the subscribed channel fails, it will switch
subscription to the other channel.</p><h3 id="jd0e682">Route Channel</h3><p>This channel is used to exchange routes between Agent and Contrail
controller. Agent connects to two Contrail controllers at a time and
routes are exchanged between both of the channels. Routes from each
of the channels is added with a different "Route Peer." When one of
the channels fails, it only deletes "Route Path" from the channel
that failed.</p><h4 id="jd0e687">Route Export</h4><p>Agent exports routes for <code class="inline" v-pre="">virtual-machines</code> created on the local compute node. Agent exports the route with
the following information:</p><ul><li style=""><p>Routing instance for the route.</p></li><li style=""><p>Destination network for the route (also called a <code class="inline" v-pre="">route-prefix</code>).</p></li><li style=""><p>Next hop information:</p><ul><li style=""><p>MPLS label for route if MPLSoGRE or MPLSoUDP encapsulation
is used.</p></li><li style=""><p>VXLAN ID for route if VXLAN encapsulation is used.</p></li><li style=""><p>Gateway for the route. This is implicitly derived from
the XMPP channel.</p></li><li style=""><p>Security group membership for the routes.</p></li></ul></li></ul><p>The control node implicitly derives the <code class="inline" v-pre="">virtual-network</code> name for the route from the <code class="inline" v-pre="">routing-instance</code>.</p><h4 id="jd0e729">Route Import</h4><p>Agent subscribes to all <code class="inline" v-pre="">routing-instances</code> in the VRF table. The <code class="inline" v-pre="">contrail-controller</code> collects routes from all Agents. Controller synchronizes routes
in a <code class="inline" v-pre="">routing-instance</code> if Agent is subscribed
to the <code class="inline" v-pre="">routing-instance</code>.</p><p>Routes are exchanged between Agent and <code class="inline" v-pre="">contrail-controller</code> over the XMPP channel in XML format.</p><p>Controller module decodes the XMPP messages and adds or deletes
"Route Paths" into the routing tables. The <code class="inline" v-pre="">contrail-controller</code> provides the following information for every route:</p><ul><li style=""><p>Routing instance for the route.</p></li><li style=""><p>Destination network for the route.</p></li><li style=""><p>MPLS label for the route if MPLSoGRE or MPLSoUDP encapsulation
is being used.</p></li><li style=""><p>VXLAN ID for route if VXLAN encapsulation is used.</p></li><li style=""><p>Gateway for the route. This is implicitly derived from
the XMPP channel.</p></li><li style=""><p>Security group membership for the routes.</p></li><li style=""><p>Virtual network for the route.</p></li></ul><p>The <code class="inline" v-pre="">contrail-controller</code> also reflects
back the routes added by Agent itself. When the route is received,
Agent looks at the gateway IP address to identify if the route is
hosted on a local compute node or a remote compute node. If the route
is hosted on a remote compute node, the Controller module creates
a next hop tunnel to be used in route. If the route is hosted on a
local compute node, a route pointing to the next hop interface is
added.</p><h3 id="jd0e783">Headless Mode</h3><p>When the XMPP channel from Agent to the Contrail controller
fails, Agent flushes all of the "Route Paths" added by the controller.
If the connection to both of the Contrail controllers fail, this can
result in deleting routes distributed by the controller.</p><p>Connections to Contrail controllers can fail for many reasons
including network failure, Contrail controller node failing, and so
on. Deleting paths can result in connectivity loss between virtual
machines.</p><p>Headless mode is introduced as a resilient mode of operation
for Agent. When running in headless mode, Agent retains the last "Route
Path" from Contrail controller. The "Route Paths" are held until a
new stable connection is established to one of the Contrail controllers.
Once the XMPP connection is up and is stable for a predefined duration,
the "Route Paths" from the old XMPP connection are flushed.</p><h2 id="jd0e792">Agent KSync</h2><p>Oper-DB in Agent contains different tables and defines the data
model used in the Agent. While the Agent data model was initially
developed for Contrail vRouter agent, it is mostly independent of
the underlying forwarding platform.</p><p>The data model used by datapath can vary based on the platform
being ports. Agent KSync module is responsible to do the translation
between the data model used by Agent and the datapath.</p><p>The functionality of Agent KSync includes:</p><ul><li style=""><p>Provide translation between the data model of Agent and
the forwarding plane.</p><ul><li style=""><p> KSync will be aware of the data model used in the data
plane.</p></li><li style=""><p>Oper-DB defines the data module for Agent.</p></li></ul></li><li style=""><p>Keeps the operational state of Agent in sync with the
forwarding plane.</p></li><li style=""><p>Keep Agent platform independent.</p><p>Ex: KSync in Contrail vRouter agent is the only module that
knows which flow table is memory mapped into the Contrail vRouter
Agent memory.</p></li></ul><h2 id="jd0e820">UVE</h2><p>UVE module is responsible for generating UVE messages to the
collector. UVE module registers with Oper-DB and also polls the flows/vrouter
to generate the UVE messages to the collector.</p><h2 id="jd0e825">Services</h2><p>This module is responsible to run the following services in
Agent:</p><ul><li style=""><p>ARP</p></li><li style=""><p>DHCP</p></li><li style=""><p>DNS</p></li><li style=""><p>Ping</p></li><li style=""><p>ICMP error generation</p></li></ul><sw-prev-next> </sw-prev-next></p>